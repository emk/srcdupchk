srcdupchk - Program to find duplication between two source trees.
Copyright (C) 2003 Eric Kidd <eric.kidd@pobox.com>

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

IF YOU RUN SRCDUPCHK ON OTHER PEOPLE'S CODE, PLEASE DO NOT PUBLISH THE
RESULTS.  THE OUTPUT OF SRCDUPCHK REVEALS QUITE A BIT OF INFORMATION ABOUT
THE INPUT CODE.  YOU SHOULD ASSUME THAT ANY NON-DISCLOSURE AGREEMENT WHICH
COVERS THE INPUT CODE ALSO COVERS THE OUTPUT OF SRCDUPCHK.

I wrote srcdupchk because--like many users of Linux and GNU systems--I take
copyright violations VERY seriously.  I write software for a living, and
don't want my own code misused.  If you think your code has been improperly
included in Linux or another free program, please run srcdupchk and foward
the ouput to the appropriate maintainer.  Like most software developers, I
don't fear the truth, and want to end any wrongdoing swiftly.  But if you
don't report problems to the right people, those problems will continue.
Please, give us chance to help you; we want to do so.

How to Install It
-----------------

You need a modern Linux or Unix system with a decent C++ compiler.  Log in
as root and type:

  $ ./configure
  $ make
  $ make install

What It Does
------------

  srcdupchk [--show-shreds] [--show-matches] [--shred-size N] TREE1 TREE2

srcdupchk analyzes two source trees--call them TREE1 and TREE2--for
matches, and outputs any source ranges in TREE2 which can also be found in
TREE1.  Unless you ask srcdupchk to do so, it will not print out any file
names or line numbers for TREE1.

srcdupchk uses the "shred" algorithm proposed by an anonymous Inquirer
reader, but does a little preprocessing to account for typical
differences in coding style, including indentation, whitespace, brace
placement and choice of comment characters.  It also ignores any CVS
directories and any lines starting with '#include' (which tend to contain
large numbers of spurious duplicates).

See Egan Orion's article here: http://theinquirer.net/?article=10061

My main goal in writing srcdupchk is to make it easy for proprietary
software vendors to notify maintainers of free software about any
contributors who are misusing copyrighted code.  In my experience, free
software developers are well-informed about copyrights, and deeply wish to
respect copyright law.  But if you don't notify them of any problems, they
can't help you, and they can't bar dishonest contributors.

Besides tracking down potential copyright violations in free software so
you can report them, there are a few other interesting and legitimate uses
of srcdupchk:

 1) You can find out if any Linux or GNU code has been copied into your
    company's proprietary software, and remove it.  If you're improperly
    using GPL'd code, you can contact the GPL Compliance Lab at the Free
    Software Foundation <http://www.fsf.org/>.  I've worked with them
    before; they're exceptionally helpful and committed to ending problems
    discretely.

 2) You can compare various free projects with each other, and look to
    see how much code they share.  It would be fun to look at 4.4 BSD Lite,
    FreeBSD, NetBSD, OpenBSD, Linux and the HURD, and see how much overlap
    there is between the various kernels.

Legal Issues
------------

See the warnings at the top of this file.  As your lawyers will tell you,
you shouldn't run srcdupchk on other people's code, especially if it's
protected by an NDA.  If your lawyers aren't cautious enough, have them
consider the following scenarios:

You have a license and NDA for PROPCODE, a hypothetical proprietary
program.  You also have a license and NDA for FREECODE, a hypothetical
program under the GNU General Public License.  You compare PROPCODE and
FREECODE, and carefully remove all references to PROPCODE from the output.
Your output now refers only to FREECODE, and you publish it.

I can think of at least two ways this might violate your NDA (there are
probably more--consult your lawyer):

  1) Both PROPCODE and FREECODE contain NIFTYLIB, a public domain library.
     You've just revealed that PROPCODE uses NIFTYLIB--and I've known
     lawyers who would consider this a highly important trade secret.

  2) The authors of PROPCODE have borrowed code from FREECODE in violation
     of FREECODE's license.  You've just revealed that the authors of
     PROPCODE have committed copyright violations.  This could definitely
     annoy the lawyers responsible for PROPCODE.

Sample Output
-------------

I deleted a few autogenerated files from srcdupchk, and compared it to GNU
textutils (the origin of the md5.h and md5.c files in this distribution).
I found the following matches:

  // Output from 'srcdupchk-bin textutils-2.1 srcdupchk'.
  srcdupchk/COPYING:1:340               // Verbatim copy of GPL.
  srcdupchk/DcHeaders.h:6:18            // GPL license notice.
  srcdupchk/DirWalker.cpp:6:18          // GPL license notice.
  srcdupchk/DirWalker.h:6:18            // GPL license notice.
  srcdupchk/DupChecker.cpp:6:18         // GPL license notice.
  srcdupchk/FileInfo.cpp:6:18           // GPL license notice.
  srcdupchk/FileInfo.h:6:18             // GPL license notice.
  srcdupchk/HashCode.cpp:6:18           // GPL license notice.
  srcdupchk/HashCode.h:6:18             // GPL license notice.
  srcdupchk/INSTALL:1:230               // Standard GNU file.
  srcdupchk/SourceTreeChecker.cpp:6:18  // GPL license notice.
  srcdupchk/SourceTreeChecker.h:6:18    // GPL license notice.
  srcdupchk/SourceTreeInfo.cpp:6:18     // GPL license notice.
  srcdupchk/SourceTreeInfo.h:6:18       // GPL license notice.
  srcdupchk/UnitTest.cpp:6:18           // GPL license notice.
  srcdupchk/UnitTest.h:6:18             // GPL license notice.
  srcdupchk/config.h.in:3:19            // Output of autoheader program.
  srcdupchk/md5.c:1:416                 // Taken from textutils.
  srcdupchk/md5.h:1:161                 // Taken from textutils.
  srcdupchk/test1/subdir/c.txt:4:7      // Coincidence: Similar test data!

Algorithm
---------

Here's how we compute file shreds for a directory tree:

  1) Walk the directory tree recursively, skipping ".", ".." and "CVS".
  2) For each file in the directory tree, check whether it is binary by
     looking at the first 512 characters.  If any of these characters are
     NULL, or more than 10% have the high bit set, assume the file is binary.
  3) For each non-binary file:
     3a) Read in all the lines in the file.
     3b) Normalize lines by removing the characters " \t\r/*{}".  This
         attempts to correct for differences in whitespace, commenting style
         and brace placement.
     3c) Discard empty lines and all lines beginning with "#include".  The
         latter don't contain useful information, and tend to generate
         false positives for small shred sizes.
     3d) Group the remaining lines into overlapping N-line chunks and
         calculate a 128-bit cryptographic hash for each chunk.

About cryptographic hashes: On average, you'd have to look at
18,446,744,073,709,551,616 such chunks before two cryptographic hashes
matched accidentally.  This number is about 9 billion times larger than the
number of chunks in GM's infamous 2 billion line codebase--probably the
largest in the world.  Modern operating systems typically contain between 1
million and 100 million chunks.

Performance
-----------

srcdupchk is a CPU and RAM hog, because I wrote in C++ in under 24 hours,
and haven't bothered to optimize it.  It can process the Linux kernel in
about 3 minutes and 140MB of RAM on an 800MHz laptop.

The biggest CPU hotspot, according to gprof, is the FileInfo::Shredder
function, which takes up 80% of the time (excluding the call to md5_buffer,
which can't be avoided or optimized much further).  Within that function,
the biggest hotspots appear to be std::getline and Normalize, which each
take around 30% of the CPU time.

The biggest use of memory is SourceTreeInfo::ShredMap, which contains one
entry for each of several million shreds.  It uses std::map, which is
remarkably fast in my tests, but definitely uses more memory than a
well-designed custom data structure.

Contributing
------------

Please feel free to e-mail me your patches or feature requests; I'll try to
get back to you within a week or two.  If you want to add new features,
PLEASE PLEASE PLEASE use the existing coding style, check carefully for
bugs, and WRITE TEST CASES BEFORE WRITING CODE.  If you don't do these
things, the chances of your patches getting applied go down by about 90%.

srcdupchk's internals are fairly reusable; feel free to adapt the code to
solve other problems.
